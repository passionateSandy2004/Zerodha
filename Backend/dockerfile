# Combined Dockerfile - Chromium + chromedriver verification + production gunicorn
FROM python:3.11-slim

# Basic env
ENV DEBIAN_FRONTEND=noninteractive
ENV PYTHONUNBUFFERED=1
ENV CHROME_BIN=/usr/bin/chromium
ENV CHROMEDRIVER_PATH=/usr/lib/chromium/chromedriver
ENV PATH="$PATH:/root/.local/bin"

WORKDIR /app

# Install chromium, chromedriver and required libs for headless chrome
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
      chromium \
      chromium-driver \
      ca-certificates wget curl gnupg unzip \
      fonts-liberation libnss3 libxss1 libasound2 \
      libatk1.0-0 libatk-bridge2.0-0 libcups2 libxrandr2 \
      libxcomposite1 libxdamage1 libxfixes3 libxcursor1 libxtst6 \
      xdg-utils \
      && rm -rf /var/lib/apt/lists/*

# Immediate verification & helpful debug output (keeps useful messages in image build logs)
RUN echo "=== Chrome/ChromeDriver verification ===" && \
    echo "chromium binary:" && which chromium || true && \
    echo "ls primary locations:" && \
    ls -la /usr/bin/chromium /usr/lib/chromium/chromedriver /usr/bin/chromedriver 2>/dev/null || true && \
    echo "find chromedriver files (if any):" && find /usr -name "*chromedriver*" 2>/dev/null || true

# Make symlinks for compatibility (some libs expect google-chrome or /usr/local/bin/chromedriver)
RUN ln -sf /usr/bin/chromium /usr/bin/google-chrome || true && \
    if [ -f /usr/bin/chromedriver ]; then ln -sf /usr/bin/chromedriver /usr/local/bin/chromedriver || true; fi || true

# Copy only requirements first for layer caching. Adjust path if requirements.txt is elsewhere.
COPY Backend/requirements.txt /app/requirements.txt

# Install Python deps
RUN pip install --upgrade pip && \
    pip install --no-cache-dir -r /app/requirements.txt

# Copy application code (adjust if your app is at repo root)
COPY Backend/ /app/

# If you have a start script that sets up things, ensure it's executable
# (optional) keep this if you use start.sh, otherwise we'll run gunicorn directly
RUN if [ -f /app/start.sh ]; then chmod +x /app/start.sh; fi

# Create a non-root user and give ownership of /app
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# Expose an informational port (Render sets $PORT at runtime)
EXPOSE 10000

# Optional healthcheck (shell form so $PORT from runtime is expanded)
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f "http://localhost:${PORT:-5000}/health" || exit 1

# Final command:
# - Use gunicorn as the production server and bind to the runtime $PORT (Render provides $PORT).
# - IMPORTANT: change "app:app" to the module:variable that creates your Flask app (e.g., main:app, wsgi:app)
# If you prefer to use start.sh (which should call gunicorn with $PORT), replace the CMD accordingly.
CMD ["sh", "-c", "exec gunicorn --bind 0.0.0.0:${PORT} app:app --workers 2 --threads 2"]
